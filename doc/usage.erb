%#--
%# Copyright protects this work.
%# See LICENSE file for details.
%#++

% dfect_api = 'api/classes/Dfect.html'


%|chapter "Usage"

  Begin by loading <%= $project %> into your program:

  %|code :ruby
    require 'rubygems'
    require 'dfect'

  You now have access to the [`Dfect` module](<%= dfect_api %>), which provides mixin-able instance methods that are also directly-callable as class methods:

  %|code :ruby
    Dfect.D "hello" do  # D() is a class method
      puts "world"
    end

    # the above is same as:

    include Dfect       # mix-in the Dfect API

    D "hello" do        # D() is an instance method
      puts "world"
    end

  The following sections explain these provided methods in detail.  If you are impatient, you can skip to <%= xref "A sample unit test" %> for an illustrative example.


  %|section "Assertions"

    The following methods accept a block parameter and assert something about the result of executing that block.  They also accept an optional message, which is shown in <%= xref "Failures", "failure reports" %> if they fail.

    See the [API documentation](<%= dfect_api %>) for examples.

    %|table
      %|thead
        %|tr
          %|th
            Method
          %|th
            Description
      %|tbody
        %|tr
          %|td
            F
          %|td
            assert not true (`nil` or `false`)
        %|tr
          %|td
            E
          %|td
            assert that an execption is raised
        %|tr
          %|td
            C
          %|td
            assert that a symbol is thrown
        %|tr
          %|td
            T
          %|td
            assert true (not `nil` and not `false`)


    %|paragraph "Negation"

      These methods are the *opposite* of <%= xref "Assertions", "normal assertions" %>.

      %|table
        %|thead
          %|tr
            %|th
              Method
            %|th
              Description
        %|tbody
          %|tr
            %|td
              F!
            %|td
              same as T
          %|tr
            %|td
              E!
            %|td
              assert that an execption is *not* raised
          %|tr
            %|td
              C!
            %|td
              assert that a symbol is *not* thrown
          %|tr
            %|td
              T!
            %|td
              same as F


    %|paragraph "Sampling"

      These methods allow you to *check the outcome* of an <%= xref "Assertions", "assertion" %> without the penalty of pass or failure.

      %|table
        %|thead
          %|tr
            %|th
              Method
            %|th
              Description
        %|tbody
          %|tr
            %|td
              F?
            %|td
              returns `true` if F passes; `false` otherwise
          %|tr
            %|td
              E?
            %|td
              returns `true` if E passes; `false` otherwise
          %|tr
            %|td
              C?
            %|td
              returns `true` if C passes; `false` otherwise
          %|tr
            %|td
              T?
            %|td
              returns `true` if T passes; `false` otherwise


    %|section "Failures"

      When an assertion fails, details about the failure will be shown:

          - fail: block must yield true (!nil && !false)
            code: |-
              [12..22] in test/simple.rb
                 12
                 13     D "with more nested tests" do
                 14       x = 5
                 15
                 16       T { x > 2 }   # passes
              => 17       F { x > 2 }   # fails
                 18       E { x.hello } # passes
                 19     end
                 20   end
                 21
                 22   # equivalent of before(:each) or setup()
            vars:
              x: 5
              y: 83
            call:
            - test/simple.rb:17
            - test/simple.rb:3

      You will then be placed into a debugger to investigate the failure if the `:debug` option is enabled in [`Dfect.options`](<%= dfect_api %>).

      Details about all assertion failures and a trace of all tests executed are stored by <%= $project %> and provided by the [`Dfect.report`](<%= dfect_api %>) method.


  %|section "Tests"

    The [`D()` method](<%= dfect_api %>) defines a new **test**, which is analagous to the `describe()` environment provided by BDD frameworks like RSpec.

    A test may also contain nested tests.

    %|code :ruby
      D "outer test" do
        # assertions and logic here

        D "inner test" do
          # more assertions and logic here
        end
      end


    %|section "Hooks"

      The [`D()` method](<%= dfect_api %>) provides several entry points (hooks) into the test execution process:

      %|code :ruby
        D "outer test" do
          D .<  { puts "before each nested test" }
          D .>  { puts "after  each nested test" }
          D .<< { puts "before all nested tests" }
          D .>> { puts "after  all nested tests" }

          D "inner test" do
            # assertions and logic here
          end
        end

      A hook method may be called multiple times.  Each call registers additional logic to execute during the hook:

      %|code :ruby
        D .< { puts "do something" }
        D .< { puts "do something more!" }


    %|section "Insulation"

      Use the singleton class of a temporary object to shield your test logic from Ruby's global environment, the code being tested, and from other tests:

      %|code :ruby
        class << Object.new
          # your test logic here
        end

      Inside this insulated environment, you are free to:
      * mix-in any modules your test logic needs
      * define your own constants, methods, and classes

      For example:

      %|code :ruby
        class << Object.new
          include SomeModule
          extend AnotherModule

          YOUR_CONSTANT = 123

          D "your tests here" do
            # your test logic here

            your_helper_method
          end

          def self.your_helper_method
            # your helper logic here

            helper = YourHelperClass.new
            helper.do_something_helpful

            T { 2 + 2 != 5 }
          end

          class YourHelperClass
            # your helper logic here
          end
        end


  %|section "Execution"

    You can configure test execution using:

    %|code :ruby
      Dfect.options = your_options_hash

    You can execute all tests defined thus far using:

    %|code :ruby
      Dfect.run

    You can stop this execution at any time using:

    %|code :ruby
      Dfect.stop

    You can view the results of execution using:

    %|code :ruby
      puts Dfect.report.to_yaml

    See the [API documentation](<%= dfect_api %>) for details and examples.


    %|section "Automatic test execution"

      %|code :ruby
        require 'rubygems'
        require 'dfect/auto'   # <== notice the "auto"

      The above code will mix-in the `Dfect` module into your program and will execute all tests defined by your program before it terminates.


  %|example! "A sample unit test"

    The following code is from Dfect's very own test suite.

    %|code :ruby
      %< "../test/dfect.rb"
