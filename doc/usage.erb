%#--
%# Copyright protects this work.
%# See LICENSE file for details.
%#++

% dfect_api = 'api/classes/Dfect.html'


%|chapter "Usage"

  Begin by loading <%= $project %> into your program:

      require 'rubygems'
      require 'dfect'

  {:lang=ruby}

  You now have access to the [`Dfect` module](<%= dfect_api %>), which provides mixin-able instance methods that are also directly-callable as class methods:

      Dfect.D "hello" do  # D() is a class method
        puts "world"
      end

      # the above is same as:

      include Dfect       # mix-in the Dfect API

      D "hello" do        # D() is an instance method
        puts "world"
      end

  {:lang=ruby}

  The following sections explain these provided methods in detail.


  %|section "Assertions"

    The following methods take a block parameter and assert something about the result of executing that block.  See the [API documentation](<%= dfect_api %>) for examples.

    | Method | Description                             |
    | ------ | -----------                             |
    | F      | assert not true (`nil` or `false`)      |
    | E      | assert that an execption is raised      |
    | C      | assert that a symbol is thrown          |
    | T      | assert true (not `nil` and not `false`) |


    %|paragraph "Negation"

      These methods are the *opposite* of <%= xref "Assertions", "normal assertions" %>.

      | Method | Description                              |
      | ------ | -----------                              |
      | F!     | same as T                                |
      | E!     | assert that an execption is *not* raised |
      | C!     | assert that a symbol is *not* thrown     |
      | T!     | same as F                                |


    %|paragraph "Sampling"

      These methods allow you to *check the outcome* of an <%= xref "Assertions", "assertion" %> without the penalty of pass or failure.

      | Method | Description                                   |
      | ------ | -----------                                   |
      | F?     | returns `true` if F passes; `false` otherwise |
      | E?     | returns `true` if E passes; `false` otherwise |
      | C?     | returns `true` if C passes; `false` otherwise |
      | T?     | returns `true` if T passes; `false` otherwise |


    %|section "Failures"

      When an assertion fails, details about the failure will be shown:

          - fail: block must yield true (!nil && !false)
            code: |-
              [12..22] in test/simple.rb
                 12
                 13     D "with more nested tests" do
                 14       x = 5
                 15
                 16       T { x > 2 }   # passes
              => 17       F { x > 2 }   # fails
                 18       E { x.hello } # passes
                 19     end
                 20   end
                 21
                 22   # equivalent of before(:each) or setup()
            vars:
              x: 5
              y: 83
            call:
            - test/simple.rb:17
            - test/simple.rb:3

      You will then be placed into a debugger to investigate the failure if the `:debug` option is enabled in [`Dfect.options`](<%= dfect_api %>).

      Details about all assertion failures and a trace of all tests executed are stored by <%= $project %> and provided by the [`Dfect.report`](<%= dfect_api %>) method.


  %|section "Tests"

    The [`D()` method](<%= dfect_api %>) defines a new **test**, which is analagous to the `describe()` environment provided by BDD frameworks like RSpec.

    A test may also contain nested tests.

        D "outer test" do
          # assertions and logic here

          D "inner test" do
            # more assertions and logic here
          end
        end

    {:lang=ruby}


    %|section "Hooks"

      The [`D()` method](<%= dfect_api %>) provides several entry points (hooks) into the test execution process:

          D "outer test" do
            D .<  { puts "before each nested test" }
            D .>  { puts "after  each nested test" }
            D .<< { puts "before all nested tests" }
            D .>> { puts "after  all nested tests" }

            D "inner test" do
              # assertions and logic here
            end
          end

      {:lang=ruby}

      A hook method may be called multiple times.  Each call registers additional logic to execute during the hook:

          D .< { puts "do something" }
          D .< { puts "do something more!" }

      {:lang=ruby}


    %|section "Insulation"

      Use the singleton class of a temporary object to shield your test logic from Ruby's global environment, the code being tested, and from other tests:

          class << Object.new
            # your test logic here
          end

      {:lang=ruby}

      Inside this insulated environment, you are free to:
      * mix-in any modules your test logic needs
      * define your own constants, methods, and classes

      For example:

          class << Object.new
            include SomeModule
            extend AnotherModule

            YOUR_CONSTANT = 123

            D "your tests here" do
              # your test logic here

              your_helper_method
            end

            def self.your_helper_method
              # your helper logic here

              helper = YourHelperClass.new
              helper.do_something_helpful

              T { 2 + 2 != 5 }
            end

            class YourHelperClass
              # your helper logic here
            end
          end

      {:lang=ruby}


  %|section "Execution"

    You can configure test execution using:

        Dfect.options = your_options_hash

    {:lang=ruby}

    You can execute all tests defined thus far using:

        Dfect.run

    {:lang=ruby}

    You can stop this execution at any time using:

        Dfect.stop

    {:lang=ruby}

    You can view the results of execution using:

        puts Dfect.report.to_yaml

    {:lang=ruby}

    See the [API documentation](<%= dfect_api %>) for details and examples.


    %|section "Automatic test execution"

      %
          require 'rubygems'
          require 'dfect/auto'   # <== notice the "auto"

      {:lang=ruby}

      The above code will mix-in the `Dfect` module into your program and will execute all tests defined by your program before it terminates.


  %|example "A sample unit test"

    %

        require 'rubygems'
        require 'dfect/auto'

        D "a test" do
          D "a nested test" do
          end

          D "another nested test" do
          end

          D "a complex test" do
            y = 83

            D "with more nested tests" do
              x = 5

              T { x > 2 }   # passes
              F { x > 2 }   # fails
              E { x.hello } # passes
            end
          end

          D .< do
            puts "this is executed before every test in this scope"
          end

          D .> do
            puts "this is executed after every test in this scope"
          end

          D .<< do
            puts "this is executed once, before all tests in this scope"
          end

          D .>> do
            puts "this is executed once, after all tests in this scope"
          end
        end

    {:lang=ruby}

